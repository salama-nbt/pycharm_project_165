import RPi.GPIO as gpioimport smbusfrom MCP342x import MCP342xfrom pynrfjprog import LowLevelfrom pynrfjprog import HighLevelimport loggingimport serialimport time# logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)import subprocessimport osimport tempfileimport pandas as pdfrom datetime import datetimeimport uuidfrom mep_core_api_client import Configuration, APIimport urllib.requestclass RaspberryPi:    # ---- RASPI GPIO PINS ---- #    # Refer to this page: https://tnextbigthing.atlassian.net/wiki/spaces/PRD/pages/2477457486/FCT+hardware+pinout    swd_clk = 23    swd_io = 24    dut_reset = 12    on_off = 37    boost_control = 15    enable_power = 7    # This variable is used to define if one is using the SWD emulation through GPIO or the included JLink     programmer = None    # This variable is used to check if the received UART payload is correct    full_payload = False    # The following variables compose the UART payload that is evaluated (it would be better off as a dictionary)    fw_ver = ''    device_id = ''    imsi = ''    # These are the program parameters to flash the firmware to the DUT.    # It's important to keep these settings for they guarantee the proper flashing    program_options = HighLevel.ProgramOptions(        erase_action=HighLevel.EraseAction.ERASE_ALL,        reset=HighLevel.ResetAction.RESET_SYSTEM,        verify=HighLevel.VerifyAction.VERIFY_READ)    # This list will contain any generated errors.    # Thinking back, since the test stops if any errors happen it could be just a variable    errors = []    # Data frame to store the test result.    # Using pandas for this is really overkill, but it's convenient and probably more efficient (?)    test_df = pd.DataFrame(columns=['device_id', 'imsi', 'tested at', 'result', 'errors'])    # ---- MEP CONF ----- #    conf = Configuration(        username="hw-axo@nbt.ag",        password="j-HLtMY2fjZ7nfjCPeHp",        auth_url="https://stg-auth.nbt-dev.ag/",        service_url="https://stg-api.nbt-dev.ag/"    )    mep_api = API(config=conf)    # UUID for device class Prometheus-AXO-X1-Rev5.4. As of writing this comment this is the device class tha works.    device_class_id = uuid.UUID("065b222c-15dc-79e7-8000-4405415d5b39")    def __init__(self, interface=None, user=None):        # Raspberry Pi GPIO setup        gpio.setwarnings(False)        gpio.setmode(gpio.BOARD)        gpio.setup(self.on_off, gpio.IN)        gpio.setup(self.boost_control, gpio.OUT, initial=gpio.HIGH)        gpio.setup(self.enable_power, gpio.OUT, initial=gpio.HIGH)        # Serial port setup, this is for the UART communication with the DUT        self.ser = serial.Serial("/dev/ttyS0", 115200)        # There's an idea to actually create a user system, to know which operator performed the test,        # but is currently not in use        self.user = user        # Getting the time now and formatting in this somewhat non-usual way to make the log document        # file name more readable        self.today = datetime.now().strftime('%-d_%m_%Y_%H_%M')        # Set SWD interface pins on raspi to input, otherwise JLink doesn't work        if interface == 'JLINK':            gpio.setup(self.swd_io, gpio.IN)            gpio.setup(self.swd_clk, gpio.IN)            gpio.setup(self.dut_reset, gpio.IN)    def check_dut_presence(self):        """        Checks if there's a board in the test adapter and if it's closed. Then the test can proceed.        @return: True if board is found, False otherwise        """        if gpio.input(self.on_off) == 0:            # print('DUT detected, starting tests')            self.errors = []            # Initially I thought there was a power issue because there were constant problems with JLink connection.            # But I didn't observe it anymore so I think this power cycle is not necessary            # gpio.output(self.enable_power, 0)            # time.sleep(3)            # Turns the DUT ON            gpio.output(self.enable_power, 1)            time.sleep(3)            return True        else:            print('No DUT detected, please insert board to start the test.')            return False    def get_imei(self):        """        Get the IMEI of the DUT using cred.py. Output of the script is stored in variable device_id.        @return: True if no errors, False otherwise and append error EIMEI to errors list (Error IMEI)        """        try:            cmd = 'python3 cred.py --imei_only'            p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)            out, err = p.communicate()            result = out.split(b'\n')            # The only valid output is the device id itself, but we make this verification elsewhere.            self.device_id = str(result[0], encoding='utf-8')            return True        except subprocess.SubprocessError:            self.errors.append('EIMEI')            # print('Could not get DUT IMEI')            return False    def flash_certificates(self):        """        Retrieve and flash the certificates making use of the MEP API and cred.py The API only provides the public        and private keys, the root certificates are stored locally        @return: True only if the whole process is correct,        False if any error and append ECERT to the errors list (Error Certificates).        """        try:            # Getting the device ID            self.get_imei()            # Call the MEP API and add the device/get the keys            certs = self.get_certs()            # If an error occurs in the retrieving of the certificates the function            # above returns EIDNF (Error ID Not Found)            if certs == 'EIDNF':                self.errors.append('ECERT')                return False            # Create the commands that will be executed by cred.py            cmd1 = (f"python3 cred.py --sec_tag 955 --client_private_key {certs[1]} --client_cert {certs[0]} --CA_cert "                    f"mep_root_ca.pem -o multi_cred.hex")            cmd2 = 'python3 cred.py --sec_tag 956 -i multi_cred.hex --CA_cert aws-root-ca.pem'            # Execute command 1            p = subprocess.Popen(cmd1, stdout=subprocess.PIPE, shell=True)            out = str(p.communicate()[0], encoding='utf-8')            # The only valid output for this command is an empty string.            if out != '':                self.errors.append('ECERT')                return False            else:                # Execute command 2                p = subprocess.Popen(cmd2, stdout=subprocess.PIPE, shell=True)                out = str(p.communicate()[0].split(b'\n')[0], encoding='utf-8')                # The only valid output of this command is the device ID.                if out != self.device_id:                    self.errors.append('ECERT')                    return False                else:                    return True        except subprocess.SubprocessError:            self.errors.append('ECERT')            return False    def flash_app_fw(self):        """        Flash the application firmware. The hex file should be stored locally.        @return: True if no errors, False otherwise and append EFAPP to the errors list (Error Flash Application)        """        try:            api = HighLevel.API()            api.open()            self.programmer = api.get_connected_probes()[0]            probe = HighLevel.DebugProbe(api, self.programmer)            probe.program('axo_release_v1.4.hex', self.program_options)                        api.close()            return True        except (HighLevel.APIError, IndexError):            self.errors.append('EFAPP')            return False    def verify_app_fw(self):        """        Verify if the flashed application firmware is running as expected. This is a rudimentary form of QA, since        if there's a faulty peripheral we expect that the initialisation routines will catch them. If that's the case        the execution will stop and we will not receive the expected payload from the UART output.        @return: True if running correctly, False otherwise and append error EVAPP to the errors list        (Error Verifying Firmware)        """        self.fw_ver = ''        self.imsi = ''        self.full_payload = False        # I'm resetting the device here just to make sure that we don't lose any part of the UART debug output        try:            api = HighLevel.API()            api.open()            self.programmer = api.get_connected_probes()[0]            probe = HighLevel.DebugProbe(api, self.programmer)            probe.reset()            api.close()        except (HighLevel.APIError, IndexError):            return False        imsi_timer = 0        imsi_timer_start = time.time()        try:            # Making this verification time based is not the best but is actually interesting to know            while imsi_timer < 10:                received_data = self.ser.read()  # read serial port                time.sleep(0.03)                data_left = self.ser.inWaiting()  # check for remaining byte                received_data += self.ser.read(data_left)                received_data = received_data.decode('utf-8', errors='ignore')                # Checking the firmware version. Should have used regex.                if received_data.__contains__('Firmware version:'):                    self.fw_ver = received_data[                                  received_data.find('Firmware version:') + 18:received_data.find(                                      'Firmware version:') + 21]                                if received_data.__contains__('adxl37x: initDevice failed'):                    self.full_payload = None                    self.errors.append('EVAPP')                    return False                # Checking if we received the IMSI number. At this point if there's a failure we will stop                # receiving output                if received_data.__contains__('IMSI:'):                    imsi_timer_start = time.time() - imsi_timer_start                    self.imsi = received_data[                                received_data.find('IMSI:') + 6:received_data.find('IMSI:') + 21]                    # Stupid way of validating the number. Regex would be much better                    if len(self.imsi) != 15 or not self.imsi.isnumeric():                        self.full_payload = False                        self.imsi = ''                    else:                        self.full_payload = True                imsi_timer = time.time() - imsi_timer_start            if not self.full_payload and imsi_timer > 10:                # print('DUT did not returned necessary info')                self.full_payload = None                self.errors.append('EVAPP')                return False            else:                # print('App firmware running successfully')                return True        except UnicodeDecodeError:            self.errors.append('EVAPP')            # print('DUT did not returned necessary info')            return False    def flash_modem_firmware(self):        """        Flash the modem firmware. File should be stored locally        @return: True if flashed, False otherwise and append error EFMFW to erros list (Error Flash Modem Firmware)        """        try:            api = HighLevel.API()            api.open()            self.programmer = api.get_connected_probes()[0]            probe = HighLevel.IPCDFUProbe(api, self.programmer, HighLevel.CoProcessor.CP_MODEM)            probe.program('mfw_nrf9160_1.3.5.zip')            # The verify flag can also be specified in the previous command.            probe.verify('mfw_nrf9160_1.3.5.zip')            api.close()            return True        except (HighLevel.APIError, IndexError):            self.errors.append('EFMFW')            return False    def check_programmer(self):        """        Check to see if the JLink is present and essentially also if communication with MCU is happening correctly.        @return: True if working, False otherwise and append error ECPRG to the errors list (Error Checking Programmer)        """        try:            api = HighLevel.API()            api.open()            self.programmer = api.get_connected_probes()[0]            probe = HighLevel.DebugProbe(api, self.programmer)            api.deregister_probe(probe)            api.close()            return True        except (HighLevel.APIError, IndexError):            self.errors.append('ECPRG')            return False    def print_label(self):        """        Print the PCB label. Opens the label template, modifies the two fields (the readable device ID and QR code),        saves to a temp file, calls lp and sends a job to the printer that is connected via USB. This is the only test        that if failed does not fail the entire test procedure, since the DUT is actually fine.        @return: True if label is printed, False if errors and append the error EPLBL to the errors list        (Error Printing Label)        """        with open('axo_label.zpl', 'r') as file:            file_data = file.read()            file.close()        file_data = file_data.replace('^FD999916966899999', str('^FD' + self.device_id))        file_data = file_data.replace('^FDXXXX16066833412', str('^FD' + self.device_id))        temp = tempfile.NamedTemporaryFile(suffix='.zpl')        try:            temp.write(bytes(file_data, 'utf-8'))            temp.seek(0)            subprocess.call(['lp', '-d', 'Zebra_Technologies_ZTC_ZD421-300dpi_ZPL', '-o', 'raw', temp.name])            return True        # Maybe catch the subprocess error? But a broad exception is fine here        except Exception:            self.errors.append('EPLBL')            return False        finally:            temp.close()    def finish_test(self):        """        Wrap up the csv log file and clean up the temporary files for the certificates.        """        # This is a very stupid way of populating the log data frame        if self.errors:            self.test_df = pd.concat([self.test_df, pd.DataFrame.from_dict({'device_id': [self.device_id],                                                                            'imsi': [str(self.imsi)],                                                                            'tested at': [datetime.now()],                                                                            'result': ['FAIL'],                                                                            'errors': [self.errors]})])        else:            self.test_df = pd.concat([self.test_df, pd.DataFrame.from_dict({'device_id': [self.device_id],                                                                            'imsi': [str(self.imsi)],                                                                            'tested at': [datetime.now()],                                                                            'result': ['PASS'],                                                                            'errors': [None]})])        # print(self.test_df)        # This file needs to be retrieved from the Pi from time to time, to obtain the ID-IMSI pairs.        self.test_df.to_csv(f'/home/pi/Desktop/logs/session_{self.user}_{self.today}.csv')        # api = HighLevel.API()        # if not api.is_open():        #     api.open()        #     probe = HighLevel.DebugProbe(api, self.programmer)        #     api.deregister_probe(probe)        #     time.sleep(1)        #     api.close()        # # else:        # #     api.open()        # #     # probe = HighLevel.DebugProbe(api, self.programmer)        # #     # probe.reset()        # #     api.close()        urllib.request.urlcleanup()        ans = input('Press ENTER to test another unit or q to exit: ')        if ans == 'q':            exit()        def file_exist(self, file_name):                try:            with open(file_name,"r"):                return True                        except FileNotFoundError:            return False                def save_file(self, file_name,text):                try:            mode = 'r+' if self.file_exist(file_name) else 'w'            with open(file_name,mode) as file:                file.write(text)                        return file_name                        except Exception as e:            return    def get_certs(self):        """        Get the certificates for specified device and if device does not exist in MEP, also creates it.        @return: a list with the public and private keys or EIDNF if errors (Error ID Not Found)        """        try:            success, error = self.mep_api.inventory.device.get_or_create_device(                device_id=self.device_id,                device_class_id=self.device_class_id            )            if success:                certificates_name = self.mep_api.inventory.device.provision_device(self.device_id)                jovia_ca = self.save_file("mep-stg-root-ca.pem",certificates_name["ca"])                device_crt = self.save_file("client.crt",certificates_name["certChain"])                device_key = self.save_file("client.key",certificates_name["key"])                return device_crt, device_key, jovia_ca            else:                return 'EIDNF'        except (AttributeError, urllib.request.HTTPError) as exc:            return 'EIDNF'# def get_smbus():#     candidates = []#     prefix = '/dev/i2c-'#     for bus in glob.glob(prefix + '*'):#         try:#             n = int(bus.replace(prefix, ''))#             candidates.append(n)#         except:#             pass##     if len(candidates) == 1:#         return smbus.SMBus(candidates[0])#     elif len(candidates) == 0:#         raise Exception("Could not find an I2C bus")#     else:#         raise Exception("Multiple I2C busses found")### bus = get_smbus()## # Create objects for each signal to be sampled# addr68_ch0 = MCP342x(bus, 0x6a, channel=0, resolution=18)# addr68_ch1 = MCP342x(bus, 0x6a, channel=1, resolution=18)# addr68_ch2 = MCP342x(bus, 0x6a, channel=2, resolution=18)# addr68_ch3 = MCP342x(bus, 0x6a, channel=3, resolution=16)## addr69_ch0 = MCP342x(bus, 0x6e, channel=0, resolution=18)# addr69_ch1 = MCP342x(bus, 0x6e, channel=1, resolution=18)# addr69_ch2 = MCP342x(bus, 0x6e, channel=2, resolution=18)# addr69_ch3 = MCP342x(bus, 0x6e, channel=3, resolution=18)### def check_supercap():#     start_time = time.time()#     time_now = time.time()#     time_flag = 0#     while (time_now - start_time) <= 22.0:#         time_now = time.time()#         if (time_now - start_time) >= 1.0 and time_flag == 0:#             print('Time: ' + str(time.time() - start_time) + ' s\n Voltage: ' + str(#                 addr68_ch3.convert_and_read() * 3) + ' V\n Current : ' + str(#                 addr68_ch2.convert_and_read() / 10.5) + ' A')#             time_flag = 1#         if (time_now - start_time) >= 5.0 and time_flag == 1:#             r = addr68_ch3.convert_and_read()#             print('Time: ' + str(time.time() - start_time) + ' s\n Voltage: ' + str(#                 addr68_ch3.convert_and_read() * 3) + ' V\n Current : ' + str(#                 addr68_ch2.convert_and_read() / 10.5) + ' A')#             time_flag = 2#         if (time_now - start_time) >= 10.0 and time_flag == 2:#             r = addr68_ch3.convert_and_read()#             print('Time: ' + str(time.time() - start_time) + ' s\n Voltage: ' + str(#                 addr68_ch3.convert_and_read() * 3) + ' V\n Current : ' + str(#                 addr68_ch2.convert_and_read() / 10.5) + ' A')#             time_flag = 3#         if (time_now - start_time) >= 20.0 and time_flag == 3:#             r = addr68_ch3.convert_and_read()#             print('Time: ' + str(time.time() - start_time) + ' s\n Voltage: ' + str(#                 addr68_ch3.convert_and_read() * 3) + ' V\n Current : ' + str(#                 addr68_ch2.convert_and_read() / 10.5) + ' A')#             time_flag = 4##     if time_flag == 4:#         return True#     else:#         return False#### while True:#     if gpio.input(on_off) == 0:#         print('Test started')#         time.sleep(5)#         gpio.output(boost_control, 1)#         print('Supplz voltage set to 3.6 V')#         time.sleep(2)#         gpio.output(enable_power, 1)#         print('Chcking supercap charge...')#         if check_supercap():#             break